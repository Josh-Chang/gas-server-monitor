// an excerpt from https://www.npmjs.com/package/validator
const Validator = (() => {
  const isFQDN = (str, options) => {
    const default_fqdn_options = {
      require_tld: true,
      allow_underscores: false,
      allow_trailing_dot: false,
      allow_numeric_tld: false,
      allow_wildcard: false,
    };

    Util.assertString(str);
    options = Util.merge(options, default_fqdn_options);

    /* Remove the optional trailing dot before checking validity */
    if (options.allow_trailing_dot && str[str.length - 1] === '.') {
      str = str.substring(0, str.length - 1);
    }

    /* Remove the optional wildcard before checking validity */
    if (options.allow_wildcard === true && str.indexOf('*.') === 0) {
      str = str.substring(2);
    }

    const parts = str.split('.');
    const tld = parts[parts.length - 1];

    if (options.require_tld) {
      // disallow fqdns without tld
      if (parts.length < 2) {
        return false;
      }

      if (!options.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
        return false;
      }

      // disallow spaces
      if (/\s/.test(tld)) {
        return false;
      }
    }

    // reject numeric TLDs
    if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
      return false;
    }

    return parts.every((part) => {
      if (part.length > 63) {
        return false;
      }

      if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
        return false;
      }

      // disallow full-width chars
      if (/[\uff01-\uff5e]/.test(part)) {
        return false;
      }

      // disallow parts starting or ending with hyphen
      if (/^-|-$/.test(part)) {
        return false;
      }

      if (!options.allow_underscores && /_/.test(part)) {
        return false;
      }

      return true;
    });
  };

  const isIP = (str, version = '') => {
    /**
      11.3.  Examples

        The following addresses

                  fe80::1234 (on the 1st link of the node)
                  ff02::5678 (on the 5th link of the node)
                  ff08::9abc (on the 10th organization of the node)

        would be represented as follows:

                  fe80::1234%1
                  ff02::5678%5
                  ff08::9abc%10

        (Here we assume a natural translation from a zone index to the
        <zone_id> part, where the Nth zone of any scope is translated into
        "N".)

        If we use interface names as <zone_id>, those addresses could also be
        represented as follows:

                  fe80::1234%ne0
                  ff02::5678%pvc1.3
                  ff08::9abc%interface10

        where the interface "ne0" belongs to the 1st link, "pvc1.3" belongs
        to the 5th link, and "interface10" belongs to the 10th organization.
      * * */
    const IPv4SegmentFormat = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';
    const IPv4AddressFormat = `(${IPv4SegmentFormat}[.]){3}${IPv4SegmentFormat}`;
    const IPv4AddressRegExp = new RegExp(`^${IPv4AddressFormat}$`);

    const IPv6SegmentFormat = '(?:[0-9a-fA-F]{1,4})';
    const IPv6AddressRegExp = new RegExp('^(' +
      `(?:${IPv6SegmentFormat}:){7}(?:${IPv6SegmentFormat}|:)|` +
      `(?:${IPv6SegmentFormat}:){6}(?:${IPv4AddressFormat}|:${IPv6SegmentFormat}|:)|` +
      `(?:${IPv6SegmentFormat}:){5}(?::${IPv4AddressFormat}|(:${IPv6SegmentFormat}){1,2}|:)|` +
      `(?:${IPv6SegmentFormat}:){4}(?:(:${IPv6SegmentFormat}){0,1}:${IPv4AddressFormat}|(:${IPv6SegmentFormat}){1,3}|:)|` +
      `(?:${IPv6SegmentFormat}:){3}(?:(:${IPv6SegmentFormat}){0,2}:${IPv4AddressFormat}|(:${IPv6SegmentFormat}){1,4}|:)|` +
      `(?:${IPv6SegmentFormat}:){2}(?:(:${IPv6SegmentFormat}){0,3}:${IPv4AddressFormat}|(:${IPv6SegmentFormat}){1,5}|:)|` +
      `(?:${IPv6SegmentFormat}:){1}(?:(:${IPv6SegmentFormat}){0,4}:${IPv4AddressFormat}|(:${IPv6SegmentFormat}){1,6}|:)|` +
      `(?::((?::${IPv6SegmentFormat}){0,5}:${IPv4AddressFormat}|(?::${IPv6SegmentFormat}){1,7}|:))` +
      ')(%[0-9a-zA-Z-.:]{1,})?$');

    Util.assertString(str);
    version = String(version);
    if (!version) {
      return isIP(str, 4) || isIP(str, 6);
    }

    if (version === '4') {
      return IPv4AddressRegExp.test(str);
    }

    if (version === '6') {
      return IPv6AddressRegExp.test(str);
    }

    return false;
  };

  const isURL = (url, options) => {
    /*
    options for isURL method

    require_protocol - if set as true isURL will return false if protocol is not present in the URL
    require_valid_protocol - isURL will check if the URL's protocol is present in the protocols option
    protocols - valid protocols can be modified with this option
    require_host - if set as false isURL will not check if host is present in the URL
    require_port - if set as true isURL will check if port is present in the URL
    allow_protocol_relative_urls - if set as true protocol relative URLs will be allowed
    validate_length - if set as false isURL will skip string length validation (IE maximum is 2083)
    */

    const default_url_options = {
      protocols: ['http', 'https', 'ftp'],
      require_tld: true,
      require_protocol: false,
      require_host: true,
      require_port: false,
      require_valid_protocol: true,
      allow_underscores: false,
      allow_trailing_dot: false,
      allow_protocol_relative_urls: false,
      allow_fragments: true,
      allow_query_components: true,
      validate_length: true,
    };

    const wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;

    const isRegExp = (obj) => {
      return Object.prototype.toString.call(obj) === '[object RegExp]';
    };

    const checkHost = (host, matches) => {
      for (let i = 0; i < matches.length; i++) {
        let match = matches[i];
        if (host === match || (isRegExp(match) && match.test(host))) {
          return true;
        }
      }

      return false;
    };

    Util.assertString(url);
    if (!url || /[\s<>]/.test(url)) {
      return false;
    }

    if (url.indexOf('mailto:') === 0) {
      return false;
    }

    options = Util.merge(options, default_url_options);

    if (options.validate_length && url.length >= 2083) {
      return false;
    }

    if (!options.allow_fragments && url.includes('#')) {
      return false;
    }

    if (!options.allow_query_components && (url.includes('?') || url.includes('&'))) {
      return false;
    }

    let protocol, auth, host, hostname, port, port_str, split, ipv6;

    split = url.split('#');
    url = split.shift();

    split = url.split('?');
    url = split.shift();

    split = url.split('://');
    if (split.length > 1) {
      protocol = split.shift().toLowerCase();
      if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
        return false;
      }
    } else if (options.require_protocol) {
      return false;
    } else if (url.slice(0, 2) === '//') {
      if (!options.allow_protocol_relative_urls) {
        return false;
      }

      split[0] = url.slice(2);
    }

    url = split.join('://');

    if (url === '') {
      return false;
    }

    split = url.split('/');
    url = split.shift();

    if (url === '' && !options.require_host) {
      return true;
    }

    split = url.split('@');
    if (split.length > 1) {
      if (options.disallow_auth) {
        return false;
      }

      if (split[0] === '') {
        return false;
      }

      auth = split.shift();
      if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
        return false;
      }

      const [user, password] = auth.split(':');
      if (user === '' && password === '') {
        return false;
      }
    }

    hostname = split.join('@');

    port_str = null;
    ipv6 = null;
    const ipv6_match = hostname.match(wrapped_ipv6);
    if (ipv6_match) {
      host = '';
      ipv6 = ipv6_match[1];
      port_str = ipv6_match[2] || null;
    } else {
      split = hostname.split(':');
      host = split.shift();
      if (split.length) {
        port_str = split.join(':');
      }
    }

    if (port_str !== null && port_str.length > 0) {
      port = parseInt(port_str, 10);
      if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
        return false;
      }
    } else if (options.require_port) {
      return false;
    }

    if (options.host_whitelist) {
      return checkHost(host, options.host_whitelist);
    }

    if (host === '' && !options.require_host) {
      return true;
    }

    if (!isIP(host) && !isFQDN(host, options) && (!ipv6 || !isIP(ipv6, 6))) {
      return false;
    }

    host = host || ipv6;

    if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
      return false;
    }

    return true;
  };

  return {
    isURL,
  };
})();
